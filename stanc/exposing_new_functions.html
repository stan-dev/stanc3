<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>exposing_new_functions (stanc.exposing_new_functions)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../';
let search_urls = ['db.js','../sherlodoc.js'];
</script><script src="../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="../index.html">Index</a> &#x00BB; <a href="index.html">stanc</a> &#x00BB; exposing_new_functions</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1 id="exposing-new-functions-to-stanc3"><a href="#exposing-new-functions-to-stanc3" class="anchor"></a>Exposing New Functions to stanc3</h1></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#background">Background</a></li><li><a href="#adding-a-distribution-function">Adding a distribution function</a><ul><li><a href="#available-parameter-types">Available parameter types</a></li><li><a href="#available-types-of-distribution-functions">Available types of distribution functions</a></li></ul></li><li><a href="#adding-a-normal-function">Adding a normal function</a></li><li><a href="#higher-order-variadic-functions">Higher-Order Variadic functions</a></li><li><a href="#testing">Testing</a></li><li><a href="#documentation">Documentation</a></li></ul></nav></div><div class="odoc-content"><h2 id="background"><a href="#background" class="anchor"></a>Background</h2><p>For a function to be built into Stan, it has to be included in the Stan Math library and its signature has to be exposed to the compiler.</p><p>To do the latter, we have to add a corresponding line in <code>src/stan_math_signatures/Generate.ml</code>. The compiler uses the signatures defined there to do type checking. (Aside: this file generates a binary representation of the signatures, which is then stored in the executable. This is faster than re-generating the list of signatures every time the compiler is run.)</p><h2 id="adding-a-distribution-function"><a href="#adding-a-distribution-function" class="anchor"></a>Adding a distribution function</h2><p>To add a distribution, we have to find the line containing <code>let distributions =</code>. The existing distributions can be used for reference. The first argument defines the kind of function we want to add. The second argument is the base function name without the <code>_...</code> suffixes. The third argument specifies the argument types of the function. The last argument describes the memory pattern supported by this function, either an Array of Structs (AoS) or a Struct of Arrays (SoA). The following line exposes a function <code>foo_lpdf</code> which takes in a (non-vectorizable) real number and a (non-vectorizable) integer :</p><pre class="language-ocaml"><code>  ; ([Lpdf], &quot;foo&quot;, [DReal; DInt], SoA)</code></pre><p>To see the exact signatures created, we can recompile stanc using <code>make all</code> and display the signatures using <code>stanc --dump-stan-math-signatures</code>. By filtering for <code>foo</code> (for example by using <code>grep</code>), we get the following output:</p><pre class="language-ocaml"><code>$ stanc --dump-stan-math-signatures | grep foo
foo_lpdf(real, int) =&gt; real</code></pre><p>If we want to allow the first parameter to be vectorizable, we can change the signature to</p><pre class="language-ocaml"><code>  ; ([Lpdf], &quot;foo&quot;, [DVReal; DReal], SoA)</code></pre><p>This produces the following signatures:</p><pre class="language-ocaml"><code>$ stanc --dump-stan-math-signatures | grep foo
foo_lpdf(real, int) =&gt; real
foo_lpdf(vector, int) =&gt; real
foo_lpdf(row_vector, int) =&gt; real
foo_lpdf(array[] real, int) =&gt; real</code></pre><p>As we can see, allowing a parameter to be vectorized automatically produces signatures where the parameter is either <code>base type</code>, <code>vector</code>, <code>row_vector</code> or <code>array[]</code>.</p><h3 id="available-parameter-types"><a href="#available-parameter-types" class="anchor"></a>Available parameter types</h3><p>The following parameter types are available:</p><ul><li><code>DInt</code>: Scalar integer -&gt; <code>int</code></li><li><code>DReal</code>: Scalar real number -&gt; <code>real</code></li><li><code>DVector</code>: Vector -&gt; <code>vector</code></li><li><code>DMatrix</code>: Matrix -&gt; <code>matrix</code></li><li><code>DIntArray</code>: Integer array -&gt; <code>array[] int</code></li><li><code>DVInt</code>: Vectorizable integer -&gt; <code>int; array[] int</code></li><li><code>DVReal</code>: Vectorizable real number -&gt; <code>real; vector; row_vector; array[] real</code></li><li><code>DVectors</code>: Vectorizable vectors (for multivariate functions) -&gt; <code>vector, row_vector, array[] vector, array[] row_vector</code></li><li>(<code>DDeepVectorized</code>: all base types with up to 8 levels of nested containers)</li></ul><h3 id="available-types-of-distribution-functions"><a href="#available-types-of-distribution-functions" class="anchor"></a>Available types of distribution functions</h3><p>As we have seen above, specifying our function as <code>[Lpdf]</code> added the suffix <code>_lpdf</code> to our base function name. There are several types available which specify the suffixes that will be added:</p><ul><li><code>Lpmf</code>: <code>_lpmf</code></li><li><code>Lpdf</code>: <code>_lpdf</code></li><li><code>Rng</code>: <code>_rng</code></li><li><code>Cdf</code>: <code>_cdf, _lcdf</code></li><li><code>Ccdf</code>: <code>_lccdf</code></li></ul><p>Additionally, <code>full_lpdf</code> combines all suffixes of <code>Lpdf</code>, <code>Rng</code>, <code>Ccdf</code> and <code>Cdf</code>. <code>full_lpmf</code> does the same, but using the suffixes of <code>Lpmf</code> instead of <code>Lpdf</code>. Note that these two have to be used without brackets. This means we would write</p><pre class="language-ocaml"><code>  ; ([Cdf], &quot;foo&quot;, [DReal; DInt], SoA)</code></pre><p>but</p><pre class="language-ocaml"><code>  ; (full_lpdf, &quot;foo&quot;, [DReal; DInt], SoA)</code></pre><p>which corresponds to</p><pre class="language-ocaml"><code>  ; ([Lpdf; Rng; Ccdf; Cdf], &quot;foo&quot;, [DReal; DInt], SoA)</code></pre><h2 id="adding-a-normal-function"><a href="#adding-a-normal-function" class="anchor"></a>Adding a normal function</h2><p>Standard functions (e.g., not distributions or variadic functions) are added to a list in the same file. This list begins near the bottom of the file with the line</p><pre class="language-ocaml"><code>(* -- Start populating stan_math_signaturess -- *)
let () =</code></pre><p>The statements in this list use several helper functions, such as <code>add_unqualified</code>, <code>add_qualified</code>, <code>add_binary</code>, etc.</p><p>The core function of these is <code>add_qualified</code>, which registers a function based on:</p><ol><li>The name of the function</li><li>The return type (an <code>UnsizedType.returntype</code>)</li><li>A list of argument types (A list of <code>UnsizedType.autodifftype * UnsizedType.t</code> tuples)</li><li>The memory pattern supported by this function, Array of Structs (AoS) or Struct of Arrays (SoA)</li></ol><p>All other functions are simply helpers for calling this one. For example, if a function does not have any arguments it requires to be of type <code>data</code>, then <code>add_unqualified</code> is provided for convience. It does the same thing as <code>add_qualfied</code>, but the third argument is just a list of <code>UnsizedType.t</code>s. Other helpers, such as <code>add_binary</code>, exist for common cases such as a function with a signature <code>(real, real) =&gt; real</code></p><p>If a function has multiple signatures, it will generally need multiple calls to these functions. Some helpers, such as <code>add_binary_vec</code> add multiple signatures at once for vectorized functions.</p><p>For example, the following line defines the signature <code>add(real, matrix) =&gt; matrix</code></p><pre class="language-ocaml"><code>  add_unqualified (&quot;add&quot;, ReturnType UMatrix, [UReal; UMatrix], SoA) ;</code></pre><h2 id="higher-order-variadic-functions"><a href="#higher-order-variadic-functions" class="anchor"></a>Higher-Order Variadic functions</h2><p>Functions such as the ODE integrators or <code>reduce_sum</code>, which take in user-functions and a variable-length list of arguments, are <b>NOT</b> added to this list.</p><p>&quot;Nice&quot; variadic functions are added to the hashtable <code>Stan_math_signatures.stan_math_variadic_signatures</code>. This is probably sufficient for most variadic functions, e.g. all the ODE solvers and DAE solvers are done via this method. <code>reduce_sum</code> is not &quot;nice&quot;, since it is both variadic and <em>polymorphic</em>, requiring certain arguments to have the same (but <em>not predetermined</em>) type. Therefore, <code>reduce_sum</code> is treated as special case in the <code>Typechecker</code> module in the frontend folder.</p><p>Note that higher-order functions also usually require changes to the C++ code generation to work properly. It is best to consult an existing example of how these are done before proceeding.</p><h2 id="testing"><a href="#testing" class="anchor"></a>Testing</h2><p>Functions exposed from the Stan Math Library are tested for all declared signatures. These tests live in the folder <code>test/integration/good/function-signatures</code>. They consist of a basic Stan program (or multiple programs for functions with a large number of overloads) which call the new function on each possible combination of arguments.</p><p>These tests confirm both that the typechecker accepts these signatures and that the C++ generated for them compiles against the Math Library implementations.</p><h2 id="documentation"><a href="#documentation" class="anchor"></a>Documentation</h2><p>Finally, before a function can be exposed in the Stan compiler it needs to be added to the Stan Functions Reference, which is stored at <a href="https://github.com/stan-dev/docs">stan-dev/docs</a>. New PRs to stanc3 will prompt you to link to the accompanying documentation PR.</p></div></body></html>
